/*! Picturefill - v2.1.0 - 2014-07-25
* http://scottjehl.github.io/picturefill
* Copyright (c) 2014 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

window.matchMedia || (window.matchMedia = function() {
	"use strict";

	// For browsers that support matchMedium api such as IE 9 and webkit
	var styleMedia = (window.styleMedia || window.media);

	// For those that don't support matchMedium
	if (!styleMedia) {
		var style       = document.createElement('style'),
			script      = document.getElementsByTagName('script')[0],
			info        = null;

		style.type  = 'text/css';
		style.id    = 'matchmediajs-test';

		script.parentNode.insertBefore(style, script);

		// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
		info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

		styleMedia = {
			matchMedium: function(media) {
				var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

				// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
				if (style.styleSheet) {
					style.styleSheet.cssText = text;
				} else {
					style.textContent = text;
				}

				// Test if media query is true or false
				return info.width === '1px';
			}
		};
	}

	return function(media) {
		return {
			matches: styleMedia.matchMedium(media || 'all'),
			media: media || 'all'
		};
	};
}());
/*! Picturefill - Responsive Images that work today.
*  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
*  License: MIT/GPLv2
*  Spec: http://picture.responsiveimages.org/
*/
(function( w, doc ) {
	// Enable strict mode
	"use strict";

	// If picture is supported, well, that's awesome. Let's get outta here...
	if ( w.HTMLPictureElement ) {
		w.picturefill = function() { };
		return;
	}

	// HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
	doc.createElement( "picture" );

	// local object for method references and testing exposure
	var pf = {};

	// namespace
	pf.ns = "picturefill";

	// srcset support test
	pf.srcsetSupported = "srcset" in doc.createElement( "img" );
	pf.sizesSupported = w.HTMLImageElement.sizes;

	// just a string trim workaround
	pf.trim = function( str ) {
		return str.trim ? str.trim() : str.replace( /^\s+|\s+$/g, "" );
	};

	// just a string endsWith workaround
	pf.endsWith = function( str, suffix ) {
		return str.endsWith ? str.endsWith( suffix ) : str.indexOf( suffix, str.length - suffix.length ) !== -1;
	};

	/**
	 * Shortcut method for matchMedia ( for easy overriding in tests )
	 */
	pf.matchesMedia = function( media ) {
		return w.matchMedia && w.matchMedia( media ).matches;
	};

	/**
	 * Shortcut method for `devicePixelRatio` ( for easy overriding in tests )
	 */
	pf.getDpr = function() {
		return ( w.devicePixelRatio || 1 );
	};

	/**
	 * Get width in css pixel value from a "length" value
	 * http://dev.w3.org/csswg/css-values-3/#length-value
	 */
	pf.getWidthFromLength = function( length ) {
		// If no length was specified, or it is 0 or negative, default to `100vw` (per the spec).
		length = length && ( parseFloat( length ) > 0 || length.indexOf( "calc(" ) > -1 ) ? length : "100vw";

		/**
		* If length is specified in  `vw` units, use `%` instead since the div we’re measuring
		* is injected at the top of the document.
		*
		* TODO: maybe we should put this behind a feature test for `vw`?
		*/
		length = length.replace( "vw", "%" );

		// Create a cached element for getting length value widths
		if ( !pf.lengthEl ) {
			pf.lengthEl = doc.createElement( "div" );
			doc.documentElement.insertBefore( pf.lengthEl, doc.documentElement.firstChild );
		}

		// Positioning styles help prevent padding/margin/width on `html` from throwing calculations off.
		pf.lengthEl.style.cssText = "position: absolute; left: 0; width: " + length + ";";

		if ( pf.lengthEl.offsetWidth <= 0 ) {
			// Something has gone wrong. `calc()` is in use and unsupported, most likely. Default to `100vw` (`100%`, for broader support.):
			pf.lengthEl.style.cssText = "width: 100%;";
		}

		return pf.lengthEl.offsetWidth;
	};

	// container of supported mime types that one might need to qualify before using
	pf.types =  {};

	// Add support for standard mime types.
	pf.types["image/jpeg"] = true;
	pf.types["image/gif"] = true;
	pf.types["image/png"] = true;

	// test svg support
	pf.types[ "image/svg+xml" ] = doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");

	// test webp support, only when the markup calls for it
	pf.types[ "image/webp" ] = function() {
		// based on Modernizr's lossless img-webp test
		// note: asynchronous
		var img = new w.Image(),
			type = "image/webp";

		img.onerror = function() {
			pf.types[ type ] = false;
			picturefill();
		};
		img.onload = function() {
			pf.types[ type ] = img.width === 1;
			picturefill();
		};
		img.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
	};

	/**
	 * Takes a source element and checks if its type attribute is present and if so, supported
	 * Note: for type tests that require a async logic,
	 * you can define them as a function that'll run only if that type needs to be tested. Just make the test function call picturefill again when it is complete.
	 * see the async webp test above for example
	 */
	pf.verifyTypeSupport = function( source ) {
		var type = source.getAttribute( "type" );
		// if type attribute exists, return test result, otherwise return true
		if ( type === null || type === "" ) {
			return true;
		} else {
			// if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.
			if ( typeof( pf.types[ type ] ) === "function" ) {
				pf.types[ type ]();
				return "pending";
			} else {
				return pf.types[ type ];
			}
		}
	};

	/**
	* Parses an individual `size` and returns the length, and optional media query
	*/
	pf.parseSize = function( sourceSizeStr ) {
		var match = /(\([^)]+\))?\s*(.+)/g.exec( sourceSizeStr );
		return {
			media: match && match[1],
			length: match && match[2]
		};
	};

	/**
	 * Takes a string of sizes and returns the width in pixels as a number
	 */
	pf.findWidthFromSourceSize = function( sourceSizeListStr ) {
		// Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
		//                            or (min-width:30em) calc(30% - 15px)
		var sourceSizeList = pf.trim( sourceSizeListStr ).split( /\s*,\s*/ ),
			winningLength;

		for ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {
			// Match <media-condition>? length, ie ( min-width: 50em ) 100%
			var sourceSize = sourceSizeList[ i ],
				// Split "( min-width: 50em ) 100%" into separate strings
				parsedSize = pf.parseSize( sourceSize ),
				length = parsedSize.length,
				media = parsedSize.media;

			if ( !length ) {
				continue;
			}
			if ( !media || pf.matchesMedia( media ) ) {
				// if there is no media query or it matches, choose this as our winning length
				// and end algorithm
				winningLength = length;
				break;
			}
		}

		// pass the length to a method that can properly determine length
		// in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
		return pf.getWidthFromLength( winningLength );
	};

	pf.parseSrcset = function( srcset ) {
		/**
		* A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
		* https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
		*
		* 1. Let input (`srcset`) be the value passed to this algorithm.
		* 2. Let position be a pointer into input, initially pointing at the start of the string.
		* 3. Let raw candidates be an initially empty ordered list of URLs with associated 
		*    unparsed descriptors. The order of entries in the list is the order in which entries 
		*    are added to the list.
		*/
		var candidates = [];

		while ( srcset !== "" ) {
			srcset = srcset.replace(/^\s+/g,"");

			// 5. Collect a sequence of characters that are not space characters, and let that be url.
			var pos = srcset.search(/\s/g),
				url, descriptor = null;

			if ( pos !== -1 ) {
				url = srcset.slice( 0, pos );

				var last = url[ url.length - 1 ];

				// 6. If url ends with a U+002C COMMA character (,), remove that character from url
				// and let descriptors be the empty string. Otherwise, follow these substeps
				// 6.1. If url is empty, then jump to the step labeled descriptor parser.

				if ( last === "," || url === "" ) {
					url = url.replace(/,+$/, "");
					descriptor = "";
				}
				srcset = srcset.slice( pos + 1 );

				// 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and 
				// let that be descriptors.
				if ( descriptor === null ) {
					var descpos = srcset.indexOf(",");
					if ( descpos !== -1 ) {
						descriptor = srcset.slice( 0, descpos );
						srcset = srcset.slice( descpos + 1 );
					} else {
						descriptor = srcset;
						srcset = "";
					}
				}
			} else {
				url = srcset;
				srcset = "";
			}

			// 7. Add url to raw candidates, associated with descriptors.
			if ( url || descriptor ) {
				candidates.push({
					url: url,
					descriptor: descriptor
				});
			}
		}
		return candidates;
	};

	pf.parseDescriptor = function( descriptor, sizesattr ) {
		// 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list 
		// is the order in which entries are added to the list.
		var sizes = sizesattr || "100vw",
			sizeDescriptor = descriptor && descriptor.replace(/(^\s+|\s+$)/g, ""),
			widthInCssPixels = pf.findWidthFromSourceSize( sizes ),
			resCandidate;

			if ( sizeDescriptor ) {
				var splitDescriptor = sizeDescriptor.split(" ");

				for (var i = splitDescriptor.length + 1; i >= 0; i--) {
					if ( splitDescriptor[ i ] !== undefined ) {
						var curr = splitDescriptor[ i ],
							lastchar = curr && curr.slice( curr.length - 1 );

						if ( ( lastchar === "h" || lastchar === "w" ) && !pf.sizesSupported ) {
							resCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );
						} else if ( lastchar === "x" ) {
							var res = curr && parseFloat( curr, 10 );
							resCandidate = res && !isNaN( res ) ? res : 1;
						}
					}
				}
			}
		return resCandidate || 1;
	};

	/**
	 * Takes a srcset in the form of url/
	 * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
	 *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
	 *     "images/pic-small.png"
	 * Get an array of image candidates in the form of
	 *      {url: "/foo/bar.png", resolution: 1}
	 * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
	 * If sizes is specified, resolution is calculated
	 */
	pf.getCandidatesFromSourceSet = function( srcset, sizes ) {
		var candidates = pf.parseSrcset( srcset ),
			formattedCandidates = [];

		for ( var i = 0, len = candidates.length; i < len; i++ ) {
			var candidate = candidates[ i ];

			formattedCandidates.push({
				url: candidate.url,
				resolution: pf.parseDescriptor( candidate.descriptor, sizes )
			});
		}
		return formattedCandidates;
	};

	/*
	 * if it's an img element and it has a srcset property,
	 * we need to remove the attribute so we can manipulate src
	 * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
	 * this moves srcset's value to memory for later use and removes the attr
	 */
	pf.dodgeSrcset = function( img ) {
		if ( img.srcset ) {
			img[ pf.ns ].srcset = img.srcset;
			img.removeAttribute( "srcset" );
		}
	};

	/*
	 * Accept a source or img element and process its srcset and sizes attrs
	 */
	pf.processSourceSet = function( el ) {
		var srcset = el.getAttribute( "srcset" ),
			sizes = el.getAttribute( "sizes" ),
			candidates = [];

		// if it's an img element, use the cached srcset property (defined or not)
		if ( el.nodeName.toUpperCase() === "IMG" && el[ pf.ns ] && el[ pf.ns ].srcset ) {
			srcset = el[ pf.ns ].srcset;
		}

		if ( srcset ) {
			candidates = pf.getCandidatesFromSourceSet( srcset, sizes );
		}
		return candidates;
	};

	pf.applyBestCandidate = function( candidates, picImg ) {
		var candidate,
			length,
			bestCandidate;

		candidates.sort( pf.ascendingSort );

		length = candidates.length;
		bestCandidate = candidates[ length - 1 ];

		for ( var i = 0; i < length; i++ ) {
			candidate = candidates[ i ];
			if ( candidate.resolution >= pf.getDpr() ) {
				bestCandidate = candidate;
				break;
			}
		}

		if ( bestCandidate && !pf.endsWith( picImg.src, bestCandidate.url ) ) {
			picImg.src = bestCandidate.url;
			// currentSrc attribute and property to match
			// http://picture.responsiveimages.org/#the-img-element
			picImg.currentSrc = picImg.src;
		}
	};

	pf.ascendingSort = function( a, b ) {
		return a.resolution - b.resolution;
	};

	/*
	 * In IE9, <source> elements get removed if they aren't children of
	 * video elements. Thus, we conditionally wrap source elements
	 * using <!--[if IE 9]><video style="display: none;"><![endif]-->
	 * and must account for that here by moving those source elements
	 * back into the picture element.
	 */
	pf.removeVideoShim = function( picture ) {
		var videos = picture.getElementsByTagName( "video" );
		if ( videos.length ) {
			var video = videos[ 0 ],
				vsources = video.getElementsByTagName( "source" );
			while ( vsources.length ) {
				picture.insertBefore( vsources[ 0 ], video );
			}
			// Remove the video element once we're finished removing its children
			video.parentNode.removeChild( video );
		}
	};

	/*
	 * Find all `img` elements, and add them to the candidate list if they have
	 * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
	 * a `srcset` attribute at all, and they haven’t been evaluated already.
	 */
	pf.getAllElements = function() {
		var elems = [],
			imgs = doc.getElementsByTagName( "img" );

		for ( var h = 0, len = imgs.length; h < len; h++ ) {
			var currImg = imgs[ h ];

			if ( currImg.parentNode.nodeName.toUpperCase() === "PICTURE" ||
				( currImg.getAttribute( "srcset" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {
					elems.push( currImg );
			}
		}
		return elems;
	};

	pf.getMatch = function( img, picture ) {
		var sources = picture.childNodes,
			match;

		// Go through each child, and if they have media queries, evaluate them
		for ( var j = 0, slen = sources.length; j < slen; j++ ) {
			var source = sources[ j ];

			// ignore non-element nodes
			if ( source.nodeType !== 1 ) {
				continue;
			}

			// Hitting the `img` element that started everything stops the search for `sources`.
			// If no previous `source` matches, the `img` itself is evaluated later.
			if ( source === img ) {
				return match;
			}

			// ignore non-`source` nodes
			if ( source.nodeName.toUpperCase() !== "SOURCE" ) {
				continue;
			}
			// if it's a source element that has the `src` property set, throw a warning in the console
			if ( source.getAttribute( "src" ) !== null && typeof console !== undefined ){
				console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
			}

			var media = source.getAttribute( "media" );

			// if source does not have a srcset attribute, skip
			if ( !source.getAttribute( "srcset" ) ) {
				continue;
			}

			// if there's no media specified, OR w.matchMedia is supported
			if ( ( !media || pf.matchesMedia( media ) ) ) {
				var typeSupported = pf.verifyTypeSupport( source );

				if ( typeSupported === true ) {
					match = source;
					break;
				} else if ( typeSupported === "pending" ) {
					return false;
				}
			}
		}

		return match;
	};

	function picturefill( opt ) {
		var elements,
			element,
			parent,
			firstMatch,
			candidates,

		options = opt || {};
		elements = options.elements || pf.getAllElements();

		// Loop through all elements
		for ( var i = 0, plen = elements.length; i < plen; i++ ) {
			element = elements[ i ];
			parent = element.parentNode;
			firstMatch = undefined;
			candidates = undefined;

			// expando for caching data on the img
			if ( !element[ pf.ns ] ) {
				element[ pf.ns ] = {};
			}

			// if the element has already been evaluated, skip it
			// unless `options.force` is set to true ( this, for example,
			// is set to true when running `picturefill` on `resize` ).
			if ( !options.reevaluate && element[ pf.ns ].evaluated ) {
				continue;
			}

			// if `img` is in a `picture` element
			if ( parent.nodeName.toUpperCase() === "PICTURE" ) {

				// IE9 video workaround
				pf.removeVideoShim( parent );

				// return the first match which might undefined
				// returns false if there is a pending source
				// TODO the return type here is brutal, cleanup
				firstMatch = pf.getMatch( element, parent );

				// if any sources are pending in this picture due to async type test(s)
				// remove the evaluated attr and skip for now ( the pending test will
				// rerun picturefill on this element when complete)
				if ( firstMatch === false ) {
					continue;
				}
			} else {
				firstMatch = undefined;
			}

			// Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.
			if ( parent.nodeName.toUpperCase() === "PICTURE" ||
			( element.srcset && !pf.srcsetSupported ) ||
			( !pf.sizesSupported && ( element.srcset && element.srcset.indexOf("w") > -1 ) ) ) {
				pf.dodgeSrcset( element );
			}

			if ( firstMatch ) {
				candidates = pf.processSourceSet( firstMatch );
				pf.applyBestCandidate( candidates, element );
			} else {
				// No sources matched, so we’re down to processing the inner `img` as a source.
				candidates = pf.processSourceSet( element );

				if ( element.srcset === undefined || element[ pf.ns ].srcset ) {
					// Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.
					pf.applyBestCandidate( candidates, element );
				} // Else, resolution-only `srcset` is supported natively.
			}

			// set evaluated to true to avoid unnecessary reparsing
			element[ pf.ns ].evaluated = true;
		}
	}

	/**
	 * Sets up picture polyfill by polling the document and running
	 * the polyfill every 250ms until the document is ready.
	 * Also attaches picturefill on resize
	 */
	function runPicturefill() {
		picturefill();
		var intervalId = setInterval( function() {
			// When the document has finished loading, stop checking for new images
			// https://github.com/ded/domready/blob/master/ready.js#L15
			picturefill();
			if ( /^loaded|^i|^c/.test( doc.readyState ) ) {
				clearInterval( intervalId );
				return;
			}
		}, 250 );
		if ( w.addEventListener ) {
			var resizeThrottle;
			w.addEventListener( "resize", function() {
				if (!w._picturefillWorking) {
					w._picturefillWorking = true;
					w.clearTimeout( resizeThrottle );
					resizeThrottle = w.setTimeout( function() {
						picturefill({ reevaluate: true });
						w._picturefillWorking = false;
					}, 60 );
				}
			}, false );
		}
	}

	runPicturefill();

	/* expose methods for testing */
	picturefill._ = pf;

	/* expose picturefill */
	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// CommonJS, just export
		module.exports = picturefill;
	} else if ( typeof define === "function" && define.amd ){
		// AMD support
		define( function() { return picturefill; } );
	} else if ( typeof w === "object" ) {
		// If no AMD and we are in the browser, attach to window
		w.picturefill = picturefill;
	}

} )( this, this.document );

/*!
 * Glide.js
 * Version: 1.0.65
 * Simple, lightweight and fast jQuery slider
 * Author: @JedrzejChalubek
 * Site: http://jedrzejchalubek.com/
 * Licensed under the MIT license
 */
;(function ($, window, document, undefined) {

	var name = 'glide',
		defaults = {

			// {Int or Bool} False for turning off autoplay
			autoplay: 4000,
			// {Bool} Pause autoplay on mouseover slider
			hoverpause: true,

			// {Bool} Circual play
			circular: true,

			// {Int} Animation time
			animationDuration: 500,
			// {String} Animation easing function
			animationTimingFunc: 'cubic-bezier(0.165, 0.840, 0.440, 1.000)',

			/**
			 * {Bool or String} Show/hide/appendTo arrows
			 * True for append arrows to slider wrapper
			 * False for not appending arrows
			 * Id or class name (e.g. '.class-name') for appending to specific HTML markup
			 */
			arrows: true,
			// {String} Arrows wrapper class
			arrowsWrapperClass: 'slider__arrows',
			// {String} Main class for both arrows
			arrowMainClass: 'slider__arrows-item',
			// {String} Right arrow
			arrowRightClass: 'slider__arrows-item--right',
			// {String} Right arrow text
			arrowRightText: 'next',
			// {String} Left arrow
			arrowLeftClass: 'slider__arrows-item--left',
			// {String} Left arrow text
			arrowLeftText: 'prev',

			/**
			 * {Bool or String} Show/hide/appendTo bullets navigation
			 * True for append arrows to slider wrapper
			 * False for not appending arrows
			 * Id or class name (e.g. '.class-name') for appending to specific HTML markup
			 */
			navigation: true,
			// {Bool} Center bullet navigation
			navigationCenter: true,
			// {String} Navigation class
			navigationClass: 'slider__nav',
			// {String} Navigation item class
			navigationItemClass: 'slider__nav-item',
			// {String} Current navigation item class
			navigationCurrentItemClass: 'slider__nav-item--current',

			// {Bool} Slide on left/right keyboard arrows press
			keyboard: true,

			// {Int or Bool} Touch settings
			touchDistance: 60,

			// {Function} Callback before plugin init
			beforeInit: function() {},
			// {Function} Callback after plugin init
			afterInit: function() {},

			// {Function} Callback before slide change
			beforeTransition: function() {},
			// {Function} Callback after slide change
			afterTransition: function() {}

		};

	/**
	 * Slider Constructor
	 * @param {Object} parent
	 * @param {Object} options
	 */
	function Glide(parent, options) {

		// Cache this
		var self = this;

		// Extend options
		this.options = $.extend({}, defaults, options);
		// Current slide id
		this.currentSlide = 0;
		// If CSS3 Transition isn't supported switch cssSupport variable to false and use $.animate()
		this.cssSupport = ( !this.css.isSupported("transition") || !this.css.isSupported("transform") ) ? false : true;
		// If circular set offset, two cloned slides
		this.offset = (this.options.circular) ? 2 : 0;

		// Callbacks before plugin init
		this.options.beforeInit.call(this);

		// Sidebar
		this.parent = parent;
		// Initialize
		this.init();
		// Start autoplay
		this.play();

		// Callback after plugin init
		this.options.afterInit.call(this);

		/**
		 * API
		 * Returning slider methods
		 */
		return {

			/**
			 * Get current slide number
			 * @return {Int}
			 */
			current: function() {
				return -(self.currentSlide) + 1;
			},

			/**
			 * Reinit
			 * Rebuild and recalculate dimensions of slider elements
			 */
			reinit: function() {
				self.init();
			},

			/**
			 * Destroy
			 * Revert init modifications and freeze slides
			 */
			destroy: function(){
				self.destroy();
			},

			/**
			 * Start autoplay
			 */
			play: function() {
				self.play();
			},

			/**
			 * Stop autoplay
			 */
			pause: function() {
				self.pause();
			},

			/**
			 * Slide one forward
			 * @param  {Function} callback
			 */
			next: function(callback) {
				self.slide(1, false, callback);
			},

			/**
			 * Slide one backward
			 * @param  {Function} callback
			 */
			prev: function(callback) {
				self.slide(-1, false, callback);
			},

			/**
			 * Jump to specifed slide
			 * @param  {Int}   	  distance
			 * @param  {Function} callback
			 */
			jump: function(distance, callback) {
				self.slide(distance-1, true, callback);
			},

			/**
			 * Append navigation to specifet target
			 * @param  {Mixed} target
			 */
			nav: function(target) {

				/**
				 * If navigation wrapper already exist
				 * Remove it, protection before doubled navigation
				 */
				if (self.navigation.wrapper) self.navigation.wrapper.remove();

				// While target isn't specifed, use slider wrapper
				self.options.navigation = (target) ? target : self.options.navigation;
				// Build
				self.navigation();

			},

			/**
			 * Append arrows to specifet target
			 * @param  {Mixed} target
			 */
			arrows: function(target) {

				/**
				 * If arrows wrapper already exist
				 * Remove it, protection before doubled arrows
				 */
				if (self.arrows.wrapper) self.arrows.wrapper.remove();

				// While target isn't specifed, use slider wrapper
				self.options.arrows = (target) ? target : self.options.arrows;
				// Build
				self.arrows();

			}

		};

	}

	/**
	 * Building slider
	 */
	Glide.prototype.build = function() {

		/**
		 * Attatch bindings
		 */
		this.bindings();

		/**
		 * There is more than one slide
		 */
		if (this.slides.length > 1) {
			/**
			 * Circular
			 * If circular option is true
			 * Append left and right arrow
			 */
			if (this.options.circular) this.circular();

			/**
			 * Arrows
			 * If arrows option is true
			 * Append left and right arrow
			 */
			if (this.options.arrows) this.arrows();

			/**
			 * Navigation
			 * If navigation option is true
			 * Append navigation item for each slide
			 */
			if (this.options.navigation) this.navigation();
		}

		/**
		 * Attatch events
		 */
		this.events();

	};

	/**
	 * Build circular DOM elements
	 * Clone first and last slide
	 * Set wrapper width with addional slides
	 * Move slider wrapper to first slide
	 */
	Glide.prototype.circular = function() {

		/**
		 * Clone first and last slide
		 * and set width for each
		 */
		this.firstClone = this.slides.filter(':first-child').clone().width(this.slides.spread);
		this.lastClone = this.slides.filter(':last-child').clone().width(this.slides.spread);

		/**
		 * Append clodes slides to slider wrapper at the beginning and end
		 * Increase wrapper with with values of addional slides
		 * Clear translate and skip cloned last slide at the beginning
		 */
		this.wrapper.append(this.firstClone).prepend(this.lastClone).width( this.parent.width() * (this.slides.length+2) )
			.trigger('clearTransition')
				.trigger('setTranslate', [-this.slides.spread]);

	};

	/**
	 * Building navigation DOM
	 */
	Glide.prototype.navigation = function() {

		this.navigation.items = {};

		// Navigation wrapper
		this.navigation.wrapper = $('<div />', {
			'class': this.options.navigationClass
		}).appendTo(
			/**
			 * Setting append target
			 * If option is true set default target, that is slider wrapper
			 * Else get target set in options
			 * @type {Bool or String}
			 */
			(this.options.navigation === true) ? this.parent : this.options.navigation
		);

		for (var i = 0; i < this.slides.length; i++) {
			this.navigation.items[i] = $('<a />', {
				'href': '#',
				'class': this.options.navigationItemClass,
				// Direction and distance -> Item index forward
				'data-distance': i
			}).appendTo(this.navigation.wrapper);
		}

		// Add navCurrentItemClass to the first navigation item
		this.navigation.items[0].addClass(this.options.navigationCurrentItemClass);

		// If centered option is true
		if (this.options.navigationCenter) {
			// Center bullet navigation
			this.navigation.wrapper.css({
				'left': '50%',
				'width': this.navigation.wrapper.children().outerWidth(true) * this.navigation.wrapper.children().length,
				'margin-left': -(this.navigation.wrapper.outerWidth(true)/2)
			});
		}

	};

		/**
	 * Building arrows DOM
	 */
	Glide.prototype.arrows = function() {

		/**
		 * Arrows wrapper
		 * @type {Obejct}
		 */
		this.arrows.wrapper = $('<div />', {
			'class': this.options.arrowsWrapperClass
		}).appendTo(
			/**
			 * Setting append target
			 * If option is true set default target, that is slider wrapper
			 * Else get target set in options
			 * @type {Bool or String}
			 */
			(this.options.arrows === true) ? this.parent : this.options.arrows
		);

		/**
		 * Right arrow
		 * @type {Obejct}
		 */
		this.arrows.right = $('<a />', {
			'href': '#',
			'class': this.options.arrowMainClass + ' ' + this.options.arrowRightClass,
			// Direction and distance -> One forward
			'data-distance': '1',
			'html': this.options.arrowRightText
		}).appendTo(this.arrows.wrapper);

		/**
		 * Left arrow
		 * @type {Object}
		 */
		this.arrows.left = $('<a />', {
			'href': '#',
			'class': this.options.arrowMainClass + ' ' + this.options.arrowLeftClass,
			// Direction and distance -> One backward
			'data-distance': '-1',
			'html': this.options.arrowLeftText
		}).appendTo(this.arrows.wrapper);

	};

	/**
	 * Function bindings
	 */
	Glide.prototype.bindings = function() {

		var self = this,
			o = this.options,
			prefix = this.css.getPrefix();

		/**
		 * Setup slider wrapper bindings
		 * for translate and transition control
		 */
		this.wrapper.bind({

			/**
			 * Set transition
			 */
			'setTransition': function() {
				$(this).css( prefix + 'transition', prefix + 'transform ' + o.animationDuration + 'ms ' + o.animationTimingFunc);
			},

			/**
			 * Clear transition
			 * for immediate jump effect
			 */
			'clearTransition': function() {
				$(this).css( prefix + 'transition', 'none');
			},

			/**
			 * Set translate value
			 * @param  {Object} event
			 * @param  {Ind} translate
			 */
			'setTranslate': function(event, translate) {
				// if css3 suported set translate3d
				if (self.cssSupport) $(this).css( prefix + 'transform', 'translate3d(' + translate + 'px, 0px, 0px)');
				// if not set left margin
				else $(this).css('margin-left', translate);
			}

		});

	};

	/**
	 * Events controllers
	 */
	Glide.prototype.events = function() {

		/**
		 * Swipe
		 * If swipe option is true
		 * Attach touch events
		 */
		if (this.options.touchDistance) {
			this.parent.on({
				'touchstart MSPointerDown': $.proxy(this.events.touchstart, this),
				'touchmove MSPointerMove': $.proxy(this.events.touchmove, this),
				'touchend MSPointerUp': $.proxy(this.events.touchend, this)
			});
		}

		/**
		 * Arrows
		 * If arrows exists
		 * Attach click event
		 */
		if (this.arrows.wrapper) {
			$(this.arrows.wrapper).children().on('click touchstart',
				$.proxy(this.events.arrows, this)
			);
		}

		/**
		 * Navigation
		 * If navigation exists
		 * Attach click event
		 */
		if (this.navigation.wrapper) {
			$(this.navigation.wrapper).children().on('click touchstart',
				$.proxy(this.events.navigation, this)
			);
		}

		/**
		 * Keyboard
		 * If keyboard option is true
		 * Attach press event
		 */
		if (this.options.keyboard) {
			$(document).on('keyup.glideKeyup',
				$.proxy(this.events.keyboard, this)
			);
		}

		/**
		 * Slider hover
		 * If hover option is true
		 * Attach hover event
		 */
		if (this.options.hoverpause) {
			this.parent.on('mouseover mouseout',
				$.proxy(this.events.hover, this)
			);
		}

		/**
		 * Slider resize
		 * On window resize
		 * Attach resize event
		 */
		$(window).on('resize',
			$.proxy(this.events.resize, this)
		);

	};

	/**
	 * Navigation event controller
	 * On click in navigation item get distance
	 * Then slide specified distance with jump
	 */
	Glide.prototype.events.navigation = function(event) {

		if ( !this.wrapper.attr('disabled') ) {
			// Prevent default behaviour
			event.preventDefault();
			// Slide distance specified in data attribute
			this.slide( $(event.currentTarget).data('distance'), true );
		}

	};

	/**
	 * Arrows event controller
	 * On click in arrows get direction and distance
	 * Then slide specified distance without jump
	 * @param  {Obejct} event
	 */
	Glide.prototype.events.arrows = function(event) {

		if ( !this.wrapper.attr('disabled') ) {
			// Prevent default behaviour
			event.preventDefault();
			// Slide distance specified in data attribute
			this.slide( $(event.currentTarget).data('distance'), false );
		}

	};

	/**
	 * Keyboard arrows event controller
	 * Keyboard left and right arrow keys press
	 */
	Glide.prototype.events.keyboard = function(event) {

		if ( !this.wrapper.attr('disabled') ) {
			// Next
			if (event.keyCode === 39) this.slide(1);
			// Prev
			if (event.keyCode === 37) this.slide(-1);
		}

	};

	/**
	 * When mouse is over slider, pause autoplay
	 * On out, start autoplay again
	 */
	Glide.prototype.events.hover = function(event) {

		// Pasue autoplay
		this.pause();

		// When mouse left slider or touch end, start autoplay anew
		if (event.type === 'mouseout') this.play();

	};

	/**
	 * When resize browser window
	 * Reinit plugin for new slider dimensions
	 * Correct crop to current slide
	 */
	Glide.prototype.events.resize = function(event) {

		// Reinit plugin (set new slider dimensions)
		this.dimensions();
		// Crop to current slide
		this.slide(0);

	};

	/**
	 * Disable events thats controls slide changes
	 */
	Glide.prototype.disableEvents = function() {
		this.wrapper.attr( "disabled", true );
	};

	/**
	 * Enable events thats controls slide changes
	 */
	Glide.prototype.enableEvents = function() {
		this.wrapper.attr( "disabled", false );
	};

	/**
	* Touch start
	* @param  {Object} e event
	*/
	Glide.prototype.events.touchstart = function(event) {

		if ( !this.wrapper.attr('disabled') ) {
			// Cache event
			var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];

			// Get touch start points
			this.events.touchStartX = touch.pageX;
			this.events.touchStartY = touch.pageY;
			this.events.touchSin = null;
		}

	};

	/**
	* Touch move
	* From swipe length segments calculate swipe angle
	* @param  {Obejct} e event
	*/
	Glide.prototype.events.touchmove = function(event) {

		if ( !this.wrapper.attr('disabled') ) {
			// Cache event
			var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];

			// Calculate start, end points
			var subExSx = touch.pageX - this.events.touchStartX;
			var subEySy = touch.pageY - this.events.touchStartY;
			// Bitwise subExSx pow
			var powEX = Math.abs( subExSx << 2 );
			// Bitwise subEySy pow
			var powEY = Math.abs( subEySy << 2 );
			// Calculate the length of the hypotenuse segment
			var touchHypotenuse = Math.sqrt( powEX + powEY );
			// Calculate the length of the cathetus segment
			var touchCathetus = Math.sqrt( powEY );

			// Calculate the sine of the angle
			this.events.touchSin = Math.asin( touchCathetus/touchHypotenuse );

			if ( (this.events.touchSin * (180 / Math.PI)) < 45 ) event.preventDefault();
		}

	};

	/**
	* Touch end
	* @param  {Object} e event
	*/
	Glide.prototype.events.touchend = function(event) {

		if ( !this.wrapper.attr('disabled') ) {
			// Cache event
			var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];

			// Calculate touch distance
			var touchDistance = touch.pageX - this.events.touchStartX;

			// While touch is positive and greater than distance set in options
			if ( (touchDistance > this.options.touchDistance) && ( (this.events.touchSin * (180 / Math.PI)) < 45) ) {
				// Slide one backward
				this.slide(-1);
			// While touch is negative and lower than negative distance set in options
			} else if (
				(touchDistance < -this.options.touchDistance) && ( (this.events.touchSin * (180 / Math.PI)) < 45) ) {
				// Slide one forward
				this.slide(1);
			}
		}

	};

	/**
	 * Slides change & animate logic
	 * @param  {int} distance
	 * @param  {bool} jump
	 * @param  {function} callback
	 */
	Glide.prototype.slide = function(distance, jump, callback) {

		/**
		 * Stop autoplay
		 * Clearing timer
		 */
		this.pause();

		// Callbacks before slide change
		this.options.beforeTransition.call(this);

		// Setup variables
		var	self = this,
			currentSlide = (jump) ? 0 : this.currentSlide,
			slidesLength = -(this.slides.length-1),
			fromFirst = false,
			fromLast = false;

		/**
		 * Check if current slide is first and direction is previous, then go to last slide
		 * or current slide is last and direction is next, then go to the first slide
		 * else change current slide normally
		 */
		if ( currentSlide === 0 && distance === -1 ) {
			fromFirst = true;
			currentSlide = slidesLength;
		} else if ( currentSlide === slidesLength && distance === 1 ) {
			fromLast = true;
			currentSlide = 0;
		} else {
			currentSlide = currentSlide + (-distance);
		}

		/**
		 * Crop to current slide.
		 * Mul slide width by current slide number.
		 */
		var offset = this.slides.spread * currentSlide;

		/**
		 * While circular decrease offset with the width of single slide
		 * When fromFirst and fromLast flags are set, unbind events thats controls changing
		 * When fromLast flags is set, set offset to slide width mulled by slides count without cloned slides
		 * When fromFirst flags is set, set offset to zero
		 */
		if (this.options.circular) {
			offset = offset - this.slides.spread;
			if (fromLast || fromFirst) this.disableEvents();
			if (fromLast) offset = this.slides.spread * (slidesLength - 2);
			if (fromFirst) offset = 0;
		}

		/**
		 * Slide change animation
		 * While CSS3 is supported use offset
		 * if not, use $.animate();
		 */
		if (this.cssSupport) this.wrapper.trigger('setTransition').trigger('setTranslate', [offset]);
		else this.wrapper.stop().animate({ 'margin-left': offset }, this.options.animationDuration);

		/**
		 * While circular
		 */
		if (this.options.circular) {

			/**
			 * 	When fromFirst and fromLast flags are set
			 * 	after animation clear transition and bind events that control slides changing
			 */
			if (fromFirst || fromLast) {
				this.afterAnimation(function(){
					self.wrapper.trigger('clearTransition');
					self.enableEvents();
				});
			}

			/**
			 * When fromLast flag is set
			 * after animation make immediate jump from cloned slide to proper one
			 */
			if (fromLast) {
				this.afterAnimation(function(){
					fromLast = false;
					self.wrapper.trigger('setTranslate', [-self.slides.spread]);
				});
			}

			/**
			 * When fromFirst flag is set
			 * after animation make immediate jump from cloned slide to proper one
			 */
			if (fromFirst) {
				this.afterAnimation(function(){
					fromFirst = false;
					self.wrapper.trigger('setTranslate', [self.slides.spread * (slidesLength-1)]);
				});
			}

		}

		// Set to navigation item current class
		if (this.options.navigation && this.navigation.wrapper) {
			$('.' + this.options.navigationClass, (this.options.navigation === true) ? this.parent : this.options.navigation).children()
				.eq(-currentSlide)
					.addClass(this.options.navigationCurrentItemClass)
						.siblings()
							.removeClass(this.options.navigationCurrentItemClass);
		}

		// Update current slide globaly
		this.currentSlide = currentSlide;

		// Callbacks after slide change
		this.afterAnimation(function(){
			self.options.afterTransition.call(self);
			if ( (callback !== 'undefined') && (typeof callback === 'function') ) callback();
		});

		/**
		 * Start autoplay
		 * Setting up timer
		 */
		this.play();

	};

	/**
	 * Autoplay logic
	 * Setup counting
	 */
	Glide.prototype.play = function() {

		// Cache this
		var self = this;

		/**
		 * If autoplay turn on
		 * Slide one forward after a set time
		 */
		if (this.options.autoplay) {
			this.auto = setInterval(function() {
				self.slide(1, false);
			}, this.options.autoplay);
		}

	};

	/**
	 * Autoplay pause
	 * Clear counting
	 */
	Glide.prototype.pause = function() {

		/**
		 * If autoplay turn on
		 * Clear interial
		 */
		if (this.options.autoplay) this.auto = clearInterval(this.auto);

	};

	/**
	 * Call callback after animation duration
	 * Added 10 ms to duration to be sure is fired after animation
	 * @param  {Function} callback
	 */
	Glide.prototype.afterAnimation = function(callback) {

		setTimeout(function(){
			callback();
		}, this.options.animationDuration + 10);

	};

	/**
	 * Dimensions
	 * Get & set dimensions of slider elements
	 */
	Glide.prototype.dimensions = function() {

		// Get slide width
		this.slides.spread = this.parent.width();
		// Set wrapper width
		this.wrapper.width(this.slides.spread * (this.slides.length + this.offset));
		// Set slide width
		this.slides.add(this.firstClone).add(this.lastClone).width(this.slides.spread);

	};

	/**
	 * Destroy
	 * Revert init modifications and freeze slides
	 */
	Glide.prototype.destroy = function() {

		this.parent.unbind();
		this.wrapper.unbind();
		this.wrapper.removeAttr("style");
		$(this.navigation.wrapper).children().unbind();
		$(this.arrows.wrapper).children().unbind();
		this.slide(0, true);
		this.pause();

		if(this.options.circular) {
			this.firstClone.remove();
			this.lastClone.remove();
		}

	};

	/**
	 * Initialize
	 * Set wrapper
	 * Set slides
	 * Set animation type
	 */
	Glide.prototype.init = function() {

		// Set slides wrapper
		this.wrapper = this.parent.children();
		// Set slides
		this.slides = this.wrapper.children();
		// Set slider dimentions
		this.dimensions();

		// Build DOM
		this.build();

	};

	/**
	 * Methods for css3 management
	 */
	Glide.prototype.css = {

		/**
		 * Check css3 support
		 * @param  {String}  Declaration name to check
		 * @return {Boolean}
		 */
		isSupported: function(declaration) {

			var isSupported = false,
				prefixes = 'Khtml ms O Moz Webkit'.split(' '),
				clone = document.createElement('div'),
				declarationCapital = null;

			declaration = declaration.toLowerCase();
			if (clone.style[declaration] !== undefined) isSupported = true;
			if (isSupported === false) {
				declarationCapital = declaration.charAt(0).toUpperCase() + declaration.substr(1);
				for( var i = 0; i < prefixes.length; i++ ) {
					if( clone.style[prefixes[i] + declarationCapital ] !== undefined ) {
						isSupported = true;
						break;
					}
				}
			}

			if (window.opera) {
				if (window.opera.version() < 13) isSupported = false;
			}

			if (isSupported === 'undefined' || isSupported === undefined) isSupported = false;

			return isSupported;

		},

		/**
		 * Get browser css prefix
		 * @return {String} 	Returns prefix in "-{prefix}-" format
		 */
		getPrefix: function () {

			if (!window.getComputedStyle) return '';

			var styles = window.getComputedStyle(document.documentElement, '');
			return '-' + (Array.prototype.slice
				.call(styles)
				.join('')
				.match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
			)[1] + '-';

		}

	};

	$.fn[name] = function(options) {

		return this.each(function () {
			if ( !$.data(this, 'api_' + name) ) {
				$.data(this, 'api_' + name,
					new Glide($(this), options)
				);
			}
		});

	};

})(jQuery, window, document);

var delay;

delay = function(ms, func) {
  return setTimeout(func, ms);
};

$(document).ready(function() {
  var subscribe;
  $('.before-and-after .slider').glide({
    autoplay: false,
    circular: true,
    navigation: false
  });
  subscribe = function(e) {
    var fields, form, params;
    e.preventDefault();
    e.stopPropagation();
    form = $(this);
    fields = form.find('fieldset');
    params = fields.find('input').serializeArray();
    fields.attr("class", "sending");
    return $.ajax({
      type: "GET",
      url: form.attr('action') + '-json',
      jsonp: "c",
      dataType: "jsonp",
      contentType: "application/json; charset=utf-8",
      data: params,
      error: function() {
        console.log("ajax error");
        return fields.attr("class", "error");
      },
      success: function(data) {
        if (data.result === "success") {
          fields.attr("class", "success");
          return console.log(data.msg);
        } else {
          fields.attr("class", "error");
          return console.log(data.msg);
        }
      }
    });
  };
  $('a.newsletter-subscribe').each(function(i, el) {
    return $(el).click(function(e) {
      var input, popup;
      e.preventDefault();
      e.stopPropagation();
      popup = $(e.target).closest('div').find('.newsletter');
      input = popup.find('input[type=email]');
      if (popup.is(':hidden')) {
        popup.show();
        return input.focus();
      } else {
        popup.hide();
        return input.blur();
      }
    });
  });
  return $('.newsletter').each(function(i, el) {
    return $(el).find("form").submit(subscribe);
  });
});
